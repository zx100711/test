高并发

说明：引用内容均为《JAVA高并发核心编程 卷2》内容

线程的调度与时间片

>cpu的计算频率非常高，每秒计算数十亿次，因此可以将cpu的计算时间由毫秒的级别进行分段，每个小段叫做一个cpu时间片。
>
>目前操作系统的主流的调度方式是：基于cpu时间片的方式进行线程调度，线程只有得到cpu时间片才可以执行指令，此时处于执行状态，没有得到时间片的线程处于就绪状态，等待系统分配下一个时间片。由于时间片非常短，在各个线程之间快速切换，因此表现出来的特征就是多个线程在“同时执行”或“并发执行”。
>
>线程的调度模型：目前主要分为两种，分时调度模型和抢占式调度模型
>
>* 分时调度模型：系统为每个线程平均分配cpu的时间片，所有线程轮流占用cpu,即在时间片的调度上人人平等。
>* 抢占式调度模型：系统按照线程优先级分配时间片，优先级高的线程优先分配时间片，如果所有就绪的线程优先级相同，则随机选择一个，总体而言，优先级高的线程获得的时间片的相对多一些。
>
>目前大多数的操作系统采用的是抢占式调度模型，Java的线程管理是委托给操作系统完成的，由此可知，Java的线程调度采用的是抢占式模型，由此可知，Java的线程都有优先级。

线程的生命周期

> ​		Java中线程的生命周期分范围6种状态，NEW(新建),RUNNABLE(可执行，包括就绪、运行两种状态)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(限时等待)、TERMINATED(终止)。
>
> 1. NEW状态：线程创建成功但并没有调用start()方法启动的线程实例属于NEW状态。这里需要说明的是，并不是线程的start()方法一经调用，其状态就由NEW状态转为RUNNABLE状态，因为此时并不意味着线程可以立即获得cpu的时间片并执行，中间还有一系列的内部操作。
>
> 2. RUNNABLE状态：当调用Thread实例的start()方法后，下一步如果线程获取到cpu的时间片开始执行，jvm将异步调用线程的run()方法执行其业务代码，那么在run()方法被异步调用前，jvm做了哪些事情呢？
>
>    ​		当java线程的Thread实例的start()方法被调用后，操作系统中的对应线程并不是进入运行状态，而是就绪状态（注意，java的线程中并没有这个状态），操作系统中线程的就绪状态是什么状态呢？
>
>    ​		操作系统中线程处于就绪状态，表示该线程已经满足执行条件，但还不能执行，处于就绪状态的线程需要等待系统的调度，一旦该线程被选中，获得cpu时间片，线程就开始占用cpu(执行该线程的代码)，这时该线程进入运行状态。
>
>    ​		操作系统中处于运行状态的线程在cpu时间片用完之后，会又回到就绪状态，等待cpu的下一次调度，这样操作系统线程就会在就绪状态与运行状态间反复循环，直到线程的代码逻辑执行结束或者发生异常终止，这时线程的状态变为最后一个状态--TERMINATED状态。 
>
>    ​		就绪状态与运行状态都是操作系统中的线程状态，在java语言中，并没有细分这两种状态，而是将两者合并为一个状态--RUNNABLE状态，因此，在Thread.State枚举类中并没有定义线程的就绪与运行状态，这就是java线程状态与操作系统中线程状态的不同之处。
>
>    总结：NEW状态的线程，被调用了start()方法之后，线程就会进入RUNNABLE状态，而其run()方法并不会马上执行，需要在线程获取到cpu时间片之后才真正启动并发执行。
>
> 3. TERMINATED状态：处于RUNNABLE状态的线程在run()方法执行完成后，就变为终止状态TERMINATED,当然，在run()方法执行过程中，如果发生了异常而且没有被捕获，run()方法将被异常终止，此时线程也进入终止状态。
> 4. TIMED_WAITING状态：线程处于一种特殊的状态，即限时等待状态。
> 5. BLOCKED状态：处于BLOCKED(阻塞)状态的线程，并不会占用cpu资源，以下两种情况会让线程进入阻塞转态：
>    * 线程等待获取锁：线程等待获取一个锁，而该锁被其他线程持有，则该线程进入阻塞状态，当其他线程释放了锁，该线程获取到锁时，该线程退出阻塞状态。
>    * IO阻塞(暂时不用看)
>
> 6. WAITING状态：处于WAITING(无限等待)状态的线程。不会被分配给cpu时间片，需要被其他线程显示的唤醒，才会进入就绪状态。以下方法会让线程进入无限等待中：
>    * Object.wait()方法，唤醒方式为Object.notify()/Object.notifyAll();
>    * Thread.join()方法，对应的唤醒方式为：被合入的线程执行结束。
>    * LockSupport.park()方法，唤醒方式为LockSupport.unpark(Thread).

阻塞状态与等待状态的区别是：



线程的基本操作

>1.线程的sleep操作：
>
>​		sleep的作用是让目前执行的线程休眠，让cpu去执行其他任务，从线程状态的角度上讲，线程从运行状态变为阻塞状态。当线程的睡眠时间到后，线程不一定立即得到执行，因为此时cpu可能在执行其他的任务，所以，线程会首先进入就绪状态，等待cpu时间片以便执行。
>
>2.线程的interrupt操作：
>
>​		java语言提供了stop()方法终止正在执行的线程，但同时将Thread的stop()方法设为过时，不建议使用，为什么？在程序中，不能随便终止一个线程的运行，因为我们无法知道线程正运行在什么状态，它可能持有某把锁，强行中断线程可能会导致锁不能释放；或者线程正在操作数据库，强行中断可能会导致数据不一致性问题，因此不推荐使用stop()方法。
>
>​		一个线程什么时候可以退出，只有线程自己知道，Thread的interrupt()方法本质上来说不是中断一个线程的，而是将线程设为中断状态。当调用interrupt()方法时，他有两个作用：
>
>​		（1）如果此线程处于阻塞状态（如调用了Object.wait()、Thread.join()、Thread.sleep()三者之一），就会立即退出阻塞，并抛出InterruptException异常，线程可以通过捕获该异常来做一些处理，然后让线程退出。
>
>​		（2）如果线程处于运行状态，线程就不会受到影响，继续运行，仅仅是线程的中断标记被设置为true.所以程序可以在适当的位置调用isInterrupt()方法来检查自己是否被中断，并退出执行（手动写代码处理）。
>
>3.线程的join操作：
>
>​		假设有两个线程A、B，线程A在执行过程中对线程B有依赖，具体依赖为：线程A需要将线程B的执行流程合并到自己的执行流程中，这就是线程合并，被动方线程B可以叫做被合并线程。调用join()方法的语句可以理解为合并点，合并的本质是：线程A需要在合并点等待，一直到线程B执行完或者等待超时。如果B线程无限时间执行，A线程可以进行限时等待，若B线程在等待时间结束后，仍未完成，则A线程继续执行。
>
>​		调用join()方法的优势是比较简单，当然劣势也很明显--join()方法无法获取B线程的执行结果。
>
>4.线程的yield操作：
>
>​		线程的yield(让步)操作的作用是让目前正在运行的的线程放弃执行，让出cpu的执行权，使cpu去执行其他线程，处于让步状态的jvm层面的线程任然是runnable状态，但是该线程对应的操作系统层面的线程状态会从执行状态变为就绪状态，注意：
>
>（1）.线程放弃执行和重新占有cpu的时间是不确定的，可能刚刚放弃cpu,马上又重新获取了cpu执行权。
>
>（2）.yield不能保证使得当前正在运行的线程迅速转换到就绪状态（切换的时间点由cpu决定？安全点？）。  
>
>总结：yield()方法只是让当前运行的线程暂停了一下，但他不会阻塞该线程，而是让线程由运行状态转入就绪状态，重新争夺cpu的使用权。

线程池原理

java中，线程的创建非常昂贵，需要JVM与OS配合完成大量的工作：
(1):必须为线程堆栈分配和初始化大量内存块，其中至少包括1MB的栈内存。
(2):需要进行系统调用，以便在OS中创建和注册本地线程。
java高并发应用频繁的创建和销毁线程非常低效，而且是不被编程规范所允许的。如何降低java创建线程的成本？必须要使用线程池，使用线程池可以解决两个问题：
(1) 提升性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。  
(2)线程管理：每个Java线程池会保持一些基本的线程统计信息，例如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步任务进行高效调度。  

java内置锁的核心原理

>​		java内置锁是一种互斥锁，这就意味着，最多只有一个线程能够获取到该锁，当线程B尝试获取线程A持有的锁时，线程B必须等待或者阻塞，直到线程A释放这个锁，如果线程A不释放，则线程B则永远等待下去。
>
>​		java中每个对象都可以用作锁，这些锁成为内置锁。线程进入同步代码块或者同步方法时，会自动获得该锁，在退出时，则会自动释放该锁。获得内置锁的唯一途径就是进入这个锁保护的同步代码块或者同步方法中。
>
>临界区资源与临界区代码片段：
>
>​		临界区资源表示一种可以被多个线程使用的公共资源或者共享数据，但是每次只能有一个线程使用它，一旦临界区资源被占用，想使用该资源的其他线程必须等待。
>
>​		临界区代码段是每个线程中访问临界区资源的那段代码，多个线程必须互斥的对临界区资源进行访问，线程进入临界区代码段之前，必须在进入区申请资源，申请成功后，执行临界区代码片段，执行完成后释放资源。在高并发情况下，可能由于在访问临界区代码片段时，没有进行互斥的访问而导致产生异常结果，这就是在临界区出现了竞态条件问题。
>
>在java中，我们使用synchronized关键字对临界区代码片段进行排他性保护。
>
>```java
>synchronized(syncObject) {
>//critical section
>}
>```
>
>在java中，也可以使用Lock显式锁、原子变量对临界区代码片段进行排他性保护。

synchronized关键字

>​		java中，线程同步使用最多的方法就是使用synchronized关键字，每个java对象中都有一把隐含的锁，使用synchronized(obj)调用相当于获取了obj的内置锁，所以可以使用内置锁对临界区代码片段进行排他性保护。
>
>​		对于小的临界区，我们直接在方法的声明中设置synchronized同步关键字，可以避免竞态条件问题，对于大的临界区代码片段，为了执行效率，最好是将同步方法分为小的临界区代码片段进行排他性保护，如下所示：
>
>```java
>// 未优化
>public class TwoPlus {
>private int sum1 = 0;
>private int sum2 = 0;
>//同步方法
>public synchronized void plus(int val1, int val2){
>   //临界区代码段
>   this.sum1 += val1;
>   this.sum2 += val2;
>}
>// 优化
>public class TwoPlus{
>private int sum1 = 0;
>private int sum2 = 0;
>private Integer sum1Lock = new Integer(1); // 同步锁一
>private Integer sum2Lock = new Integer(2); // 同步锁二
>public void plus(int val1, int val2){
>   //同步块1
>   synchronized(this.sum1Lock){
>   	this.sum1 += val1;
>   }
>   //同步块2
>   synchronized(this.sum2Lock){
>   	this.sum2 += val2;
>   }
>}
>}
>```
>
>

​		改造之后，对于独立的临界区资源sum1和sum2的加法操作可以并发执行，在某一时刻，不同的线程可以对sum1和sum2同时进行加法操作，提升了plus()方法的吞吐量。在上面的代码中，由于同步代码块1和同步代码块2保护着两个独立的临界区代码段，所以需要两个不同的锁对象，sum1Lock和sum2Lock两个成员属性没有参与业务处理，仅仅是利用了其内置锁的功能。

synchronized修饰的方法和synchronized同步代码块的区别是什么呢？

​		总体来说，synchronized修饰的方法是一种粗粒度的并发控制，某一时刻，只能有一个线程执行该synchronized方法；而synchronized同步代码块是一种细粒度的并发控制，处于同步块之外的代码可以被多个线程并发访问，在一个方法中，并不是所有代码都是临界区代码段，可能只有几行代码会涉及到线程同步问题，所以synchronized代码块比synchronized修饰的方法更加细粒度的控制了多个线程的同步访问。

synchronized方法和synchronized代码块有什么联系呢？

​		在java的内部实现上，synchronized方法实际上等同于一个synchronized代码块，这个代码块包含同步方法中的所有语句，在同步代码块的括号中传入了this关键字，使用this的对象锁作为临界区的同步锁。

```java
// 使用同步代码块
public void plus() {
    synchronized(this){ //对方法内部全部代码进行保护
    	amount++;
    }
}
// 使用synchronized方法
public synchronized void plus() {
	amount++;
}
```

synchronized方法的同步锁实质上使用了this对象锁，这样就免去了手工设置同步锁的工作。而使用synchronized代码块需要手工设置同步锁。  

静态的同步方法

​		在java的世界里一切皆对象，其实java里有两种对象：Object实例对象和Class对象。每个类运行时的类型信息用Class对象表示，它包含与类名称、继承关系、字段、方法有关的信息。JVM将一个类加载到自己的方法区内存中时，会为其创建一个Class对象，对于一个类来说，其Class对象是惟一的。

​		Class类没有公共的构造方法，Class对象是在类加载的时候由Java虚拟机调用类加载器中的defineClass方法自动构造的，因此不能显式地声明一个Class对象。所有的类都是在第一次使用时被动态加载到JVM中的（懒加载），其各个类都是在必需时才加载的。这一点与许多传统语言（如C++）都不同，JVM为动态加载机制配套了一个判定一个类是否已经被加载的检查动作，使得类加载器首先检查这个类的Class对象是否已经被加载。如果尚未加载，类加载器就会根据类的全限定名查找.class文件，验证后加载到JVM的方法区内存，并构造其对应的Class对象。

​		普通的synchronized实例方法，其同步锁是当前对象this的监视锁。如果某个synchronized方法是static（静态）方法，而不是普通的对象实例方法，其同步锁又是什么呢？  

​		大家都知道，静态方法属于Class实例而不是单个Object实例，在静态方法内部是不可以访问Object实例的this引用（也叫指针、句柄）的。所以，修饰static方法的synchronized关键字就没有办法获得Object实例的this对象的监视锁。

​			实际上，使用synchronized关键字修饰static方法时，synchronized的同步锁并不是普通Object对象的监视锁，而是类所对应的Class对象的监视锁。为了以示区分，这里将Object对象的监视锁叫作对象锁，将Class对象的监视锁叫作类锁。当synchronized关键字修饰static方法时，同步锁为类锁；当synchronized关键字修饰普通的成员方法（非静态
方法）时，同步锁为对象锁。由于类的对象实例可以有很多，但是每个类只有一个Class实例，因此使用类锁作为synchronized的同步锁时会造成同一个JVM内的所有线程只能互斥地进入临界区段。  

​		所以，使用synchronized关键字修饰static方法是非常粗粒度的同步机制。通过synchronized关键字所抢占的同步锁什么时候释放呢？一种场景是synchronized块（代码块或者方法）正确执行完毕，监视锁自动释放；另一种场景是程序出现异常，非正常退出synchronized块，监视锁也会自动释放。所以，使用synchronized块时不必担心监视锁的释放问题 。 

java对象结构与内置锁

​		java内置锁的很多重要信息都存放在对象结构中，作为铺垫，在介绍java内置锁之前，先介绍一下java对象结构。java对象包括三部分：对象头、对象体、和对齐字节，如下图所示：



* 对象头

  对象头包括三个字段，第一个是mark word（标记字），用于存储自身运行时的数据，例如CG标志位、哈希码、锁状态等信息。

  第二个字段叫作Class Pointer（类对象指针），用于存放方法区Class对象的地址，虚拟机通过这个指针来确定这个对象是哪个类的实例。  

  第三个字段叫作Array Length（数组长度）。如果对象是一个Java数组，那么此字段必须有，用于记录数组长度的数据；如果对象不是一个Java数组，那么此字段不存在，所以这是一个可选字段。  

* 对象体

  对象体包含对象的实例变量（成员变量），包括父类的成员属性值。这部分内存按4字节对齐。  

* 对齐字节

  对齐字节也叫作填充对齐，其作用是用来保证Java对象所占内存字节数为8的倍数，HotSpot VM的内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数时，便需要填充数据来保证8字节的对齐。  

对象结构中核心字段的作用

		1. Mark Word（标记字），该字段主要用来表示对象的线程锁状态，另外可以配合GC存放该对象的hashCode.
		2. Class Pointer（类对象指针），该字段是一个指向方法区中Class信息的指针，意味着该对象可以随时知道自己是哪个Class的实例。
		3. Array Length（数组长度），该字段占用32位(在32位JVM中)字节，该字段不是必须有的，只有当本对象是一个数组对象时，才会有这部分。
		4. 对象体，用于保存对象属性值，是对象的主体部分，占用的内存空间大小取决于对象的属性数量和类型。
		5. 对齐字节，并不是必须存在的，也没有特别的含义，它仅仅是起着占位符的作用，当对象实例数据部分没有对齐(8字节的整倍数)时，就需要通过对齐填充来补全。

对象结构中的字段长度

​		Mark word、Class Pointer、Array Length等字段长度都与JVM的位数有关，Mark Word、Class Pointer的长度为JVM的一个Word（字）大小，也就是说，32为的JVM中Mark Word、Class Pointer为32位，在64位JVM中两者为64位。

​		对于对象指针而言，如果JVM中的对象数量过多，使用64位的指针将会浪费大量内存，通过简单统计，64位JVM将比32位JVM多耗费50%的内存。为了节约内存，可以使用选项+UseCompressedOops开启指针压缩，其中的Oop为Ordinary Object Pointer（普通对象指针）的缩写。如果开启了指针压缩，以下类型指针将从64位压缩至32位：

* Class对象的属性指针(静态变量)。
* Object对象的属性指针(成员变量)。
* 普通对象数组的元素指针。

总结：指针压缩功能可手动开启，也可不开启。在堆内存小于32GB的情况下，64位虚拟机的UseCompressedOops选
项是默认开启的，该选项表示开启Oop对象的指针压缩会将原来64位的Oop对象指针压缩为32位。  

​		如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度（Array Length字段）。Array Length字段的长度也随着JVM架构的不同而不同：在32位JVM上，长度为32位；在64位JVM上，长度为64位。64位JVM如果开启了Oop对象的指针压缩，Array Length字段的长度也将由64位压缩至32位。  

【Q】:32位操作系统与64位操作系统的区别？

【A】:

Mark Word 的结构信息

​		Java内置锁涉及很多重要信息，都存放在对象结构中，并且存放在对象头的Mark Word中。





大小端问题

> 首先，理解：一个16bit的数值v=0x1234,内存地址：0x0010,的含义，
>
> 再理解16进制和其中的高位、低位
>
> 然后就可以理解大小端问题
>
> 高字节就是指16进制数的前8位（权重高的8位），如上例中的0x12。
> 低字节就是指16进制数的后8位（权重低的8位），如上例中的0x34。
>
> 一个内存地址代表一个字节（8bit）的存储空间，内存地址使用4位或者8位的16进制数字表示（“0x”表示十六进制，作为前缀放在十六进制的数前易于辨认），如0x0001表示编号位1的内存地址，0x0010表示编号位17的内存地址。
>
> 十进制：0、1、2、3、4、5、6、7、8、9、10、11、12、13、14、15
>
> 十六进制：0、1、2、3、4、5、6、7、8、9、A、 B、 C、D、 E、 F
>
> 所以数值x在内存中需要两个地址来存放。

| 内存地址 | 小端模式存放 | 大端模式存放 |
| -------- | ------------ | ------------ |
| 0x0001   | 0x34         | 0x12         |
| 0x0002   | 0x12         | 0x34         |

​		在处理器（即CPU）的计算过程中，因为使用小端模式在数据类型转换的时候（尤其是指针转换）不用考虑地址问题，所以小端模式是处理器的主流字节存放模式。JVM所采用的字节存放模式是小端模式。



无锁、偏向锁、轻量级锁、重量级锁

​		在jdk1.6之前，所有java的内置锁都是重量级锁，重量级锁会造成cpu在用户态和核心态之间频繁切换，效率低、代价高。jdk1.6版本为了减少获得锁和释放锁的性能消耗，引入了偏向锁和轻量级锁的实现，所以在jdk1.6版本中内置锁一共拥有4中状态：无锁状态、偏向锁、轻量级锁、重量级锁。这些状态随着线程竞争的激烈成都逐渐升级，但不可降级。

1. 无锁状态

​		java对象刚创建出来时还没有任何线程来竞争，该对象处于无锁状态（无线程竞争，不需要锁），这时偏向所的标识位是0，锁状态是01，无锁状态下对象的Mark Word如下图所示：



2. 偏向锁状态

​		偏向锁是指，一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，从而降低获取锁的代价。如果内置锁处于偏向状态，当只有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁对于竞争不激烈的情况下的并发效率非常高。

​		偏向锁状态的Mark Word 会记录内置锁自己偏爱的线程ID，内置锁会将该线程当作自己的熟人，偏向锁状态下对象的Mark Word如下图所示：



3. 轻量级锁状态

​		当有两个线程开始竞争锁对象时，内置锁的状态就不是偏向锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先获取到锁对象，锁对象的Mark Word就指向哪个线程的栈帧中的锁记录，轻量级锁状态下的Mark Word如下图所示：



​		当所处于偏向锁状态，又被另一个线程企图抢占时，偏向锁就会升级为轻量级锁。企图抢占的线程会通过自旋的方式尝试获取锁，轻量级锁不会阻塞抢锁线程，以便提高性能。

​		自旋的原理非常简单，如果持有锁的线程能在很短的时间释放掉锁资源，那么那些等待竞争锁的线程就不需要进行内核态和用户态之间的切换来进入阻塞挂起状态，他们只需要等一等(自旋)，等持有锁的线程释放掉锁后立即获取锁，这样就避免了过多资源的消耗。

​		但是自旋是需要消耗cpu的，如果一直获取不到锁，那么线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。JVM对于自旋周期的选择，在JDK1.6之后引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不是固定的，而是由前一次同一个锁上的自旋时间以及锁的拥有者状态决定的。线程如果自旋成功，下次自旋时的次数(时间)就会更多，如果失败，下次自旋的次数就会减少。

​		如果持有锁的线程执行时间超过了自旋等待的最大时间，仍没有释放锁，这会导致其他竞争锁的线程在最大等待时间内还是无法获得锁，自旋不会一直执行下去，此时竞争锁的线程就会停止自旋进入到阻塞状态，同时该锁膨胀为重量级锁。

4. 重量级锁

​		重量级锁会让其他申请锁的线程进入阻塞，性能降低。重量级锁也叫同步锁，这个锁对象Mark Word会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队线程。重量级锁的Mark Word如下图所示：



偏向锁的原理与实战

​		偏向锁主要解决无竞争情况下的锁性能问题，所谓的偏向就是偏心，即锁会偏向于当前已经占有锁的线程。

1. 偏向锁的核心原理

​		在实际场景中，如果一个同步块(或同步方法)，没有多个线程竞争，而且总是由同一个线程多次重入获取锁，如果每次还需要阻塞线程，唤醒cpu从用户态转为核心态，那么对于cpu是一种资源的浪费，为了解决这个问题，引入了偏向锁的概念。

​		偏向锁的核心原理是：如果不存在线程竞争，一个线程获得了锁，那么锁就进入偏向状态，此时Mark Word的结构变为偏向锁结构，即锁对象的标志位(lock)被改为01，偏向标志位(base_lock)被改为1，然后线程的ID被记录在对象所的Mark Word中(使用CAS操作完成)。以后该线程获取锁时，判断一下线程ID和标志位，就可以直接进入同步块，连CAS操作都不需要，这样就会省去很多有关锁申请的操作，提升了性能。

​		偏向锁在没有竞争的情况下，性能很高，但是，一旦有第二个线程需要竞争，那么偏向状态立即结束，进入轻量锁状态。

​		即在无竞争时，之前获得锁的线程再次获得锁时会判断偏向锁的线程ID是否指向自己，如果是，那么该线程将不用再次获得锁，直接就可以进入同步块；如果未指向当前线程，当前线程就会采用CAS操作将Mark Word中的线程ID设置为当前线程ID，如果CAS操作成功，那么获取偏向锁成功，执行同步代码块，如果CAS操作失败，那么表示有竞争，抢锁线程被挂起，撤销占锁线程的偏向锁，然后将偏向锁膨胀为轻量级锁。

​		偏向锁的缺点：如果锁对象时常被多个线程竞争，偏向锁就是多余的，并且其撤销的过程会带来一些性能开销。  

2. 偏向锁的膨胀和撤销

​		假如，有多个线程来竞争偏向锁，此时对象锁已经有了偏向，其他线程发现偏向锁偏向的不是自己，就说明有竞争，尝试撤销偏向锁(很有可能引入安全点)，然后膨胀到轻量级锁。

偏向锁的撤销

偏向锁撤销的开销花费还是挺大的，其大概过程如下：

1. 在一个安全点停止拥有锁的线程。
2. 遍历线程的栈帧，检查是否存在锁记录。如果存在锁记录，就需要清空锁记录，使其变成无锁状态，并修复锁记录指向的Mark Word，清除其线程ID。
3. 将当前锁升级成轻量级锁。
4. 唤醒当前线程。

​		所以，如果某些临界区存在两个及两个以上的线程竞争，那么偏向锁反而会降低性能。在这种情况下，可以在启动JVM时就把偏向锁的默认功能关闭。
撤销偏向锁的条件：

1. 多个线程竞争偏向锁。
2. 调用偏向锁对象的hashcode()方法或者System.identityHashCode()方法计算对象的HashCode之后，将哈希码放置到Mark Word中，内置锁变成无锁状态，偏向锁将被撤销。  

偏向锁的膨胀

​		如果偏向锁被占据，一旦有第二个线程争抢这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到内置锁偏向状态，这时表明在这个对象锁上已经存在竞争了。JVM检查原来持有该对象锁的占有线程是否依然存活，如果挂了，就可以将对象变为无锁状态，然后进行重新偏向，偏向为抢锁线程。
​		如果JVM检查到原来的线程依然存活，就进一步检查占有线程的调用堆栈是否通过锁记录持有偏向锁。如果存在锁记录，就表明原来的线程还在使用偏向锁，发生锁竞争，撤销原来的偏向锁，将偏向锁膨胀（INFLATING）为轻量级锁。  

偏向锁的好处

​		经验表明，其实大部分情况下进入一个同步代码块的线程都是同一个线程。这也是JDK会引入偏向锁的原因。所以，总体来说，使用偏向锁带来的好处还是大于偏向锁撤销和膨胀所带来的代价。  



























































CAS原理与JUC原子类

​		由于JVM的Synchronized是重量级锁，涉及到操作系统的内核态下互斥锁的使用，因此线程的阻塞与唤醒都会涉及到进程在用户态到内核态的频繁切换，导致重量级锁的开销大、性能低。而Synchronized的轻量级锁使用的是CAS(Compare And Swap,比较并交换)进行自旋抢锁，CAS是cpu指令级别的原子操作，并处于用户态下，所以轻量级锁的开销较小。

​		首先介绍CAS的原理及弊端，然后介绍基于CAS实现的JUC的原子类。

​		什么是CAS?

​		jdk5 所增加的JUC并发包对操作系统的底层CAS原子操作进行了封装，为上层java程序提供了CAS操作的API.

1.Unsafe类中的CAS方法

​		Unsafe类是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等，Unsafe大量的方法都是native方法，基于C++语言实现，这些方法在提升java运行效率、增强java语言底层资源操作能力方面起到了很大的作用。Unsafe类的全限定名为sun.misc.Unsafe，从名字中就可以看出这个类对于普通程序员来说是“危险”的，一般的应用级开发都不会涉及到此类，java官方也不建议直接在应用程序中使用这些类。

> ​	【说明】	
>
> ​		为什么此类取名Unsafe呢？由于使用Unsafe类可以像C语言一样使用指针操作内存空间，这无疑增加了指针的相关问题、内存泄漏问题出现的概率，会使得程序出错的概率变大，因此对于Unsafe类的使用一定要慎重。

​		操作系统层面的CAS是一条cpu的原子指令，正是由于该指令具备原子性，CAS操作数据时，不会造成数据的不一致性问题，Unsafe提供的CAS方法直接通过native方式(封装C++代码)调用底层的cpu指令。

2.使用CAS进行无锁编程

​		CAS是一种无锁算法，该算法依赖两个关键值--期望值(期望内存地址的值 oldValue)和新值，底层cpu利用原子判断操作内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。其大致步骤如下：

1. 获得字段的期望值.
2. 计算出需要替换的新值(newValue).
3. 通过CAS将新值放到字段的内存地址上，如果CAS失败，就重复1、2步直到成功，这种重复俗称CAS自旋。

使用一个简单的例子说明：

​		假如某个内存地址的值是100，现在有两个线程（A、B）使用CAS无锁编程对该内存地址进行更新，线程A欲将其更新为200，线程B欲将其更新为300，两个线程并发执行，谁都可能先执行，但是CAS是原子性操作，对同一个内存地址上的CAS操作同一时刻只能执行一个，假设A的CAS(100,200)先执行，由于内存地址的旧值与CAS的期望值都是100，线程A会执行成功，内存地址的值被改为200.

​		接下来，执行B线程的CAS(100,300)操作，此时内存地址的值为200，不等于CAS的期望值100，线程B操作失败，线程B只能自旋，开启新的循环，这一轮循环中，先获取内存地址的值200，然后在进行CAS(200,300)操作，这次内存地址的值与CAS的预期值(oldValue)相等，线程B操作成功。

​		当CAS将内存地址的值与预期值进行比较时，如果相等，就证明内存地址的值没有被修改过，可以替换成新值，然后继续往下运行，如果不相等，则说明内存地址的值被修改过，放弃操作，重新自旋。当并发修改的线程少，冲突的机会就会少，自旋的次数也会少很多，CAS的性能就会很高；当并发修改的线程多，冲突的机会也会很高，自旋的次数就会很多，此时CAS的性能就会大大下降，所以，提升CAS无锁编程的效率关键在于减少冲突的机会。



JUC原子类

​		在多线程并发执行时，诸如“++”或者“--”操作，不具备原子性，不是线程安全的操作，通常情况下，大家会使用synchronized将这些线程不安全的操作变为同步操作，但这样会降低并发程序的性能，所以jdk为这些不安全的操作提供了一些原子类，与synchronized同步机制相比，jdk原子类是基于CAS轻量级原子操作实现的，使得程序的运行效率变得更高。

























