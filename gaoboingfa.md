高并发

说明：引用内容均为《JAVA高并发核心编程 卷2》内容

线程的调度与时间片

>cpu的计算频率非常高，每秒计算数十亿次，因此可以将cpu的计算时间由毫秒的级别进行分段，每个小段叫做一个cpu时间片。
>
>目前操作系统的主流的调度方式是：基于cpu时间片的方式进行线程调度，线程只有得到cpu时间片才可以执行指令，此时处于执行状态，没有得到时间片的线程处于就绪状态，等待系统分配下一个时间片。由于时间片非常短，在各个线程之间快速切换，因此表现出来的特征就是多个线程在“同时执行”或“并发执行”。
>
>线程的调度模型：目前主要分为两种，分时调度模型和抢占式调度模型
>
>* 分时调度模型：系统为每个线程平均分配cpu的时间片，所有线程轮流占用cpu,即在时间片的调度上人人平等。
>* 抢占式调度模型：系统按照线程优先级分配时间片，优先级高的线程优先分配时间片，如果所有就绪的线程优先级相同，则随机选择一个，总体而言，优先级高的线程获得的时间片的相对多一些。
>
>目前大多数的操作系统采用的是抢占式调度模型，Java的线程管理是委托给操作系统完成的，由此可知，Java的线程调度采用的是抢占式模型，由此可知，Java的线程都有优先级。

线程的生命周期

> ​		Java中线程的生命周期分范围6种状态，NEW(新建),RUNNABLE(可执行，包括就绪、运行两种状态)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(限时等待)、TERMINATED(终止)。
>
> 1. NEW状态：线程创建成功但并没有调用start()方法启动的线程实例属于NEW状态。这里需要说明的是，并不是线程的start()方法一经调用，其状态就由NEW状态转为RUNNABLE状态，因为此时并不意味着线程可以立即获得cpu的时间片并执行，中间还有一系列的内部操作。
>
> 2. RUNNABLE状态：当调用Thread实例的start()方法后，下一步如果线程获取到cpu的时间片开始执行，jvm将异步调用线程的run()方法执行其业务代码，那么在run()方法被异步调用前，jvm做了哪些事情呢？
>
>    ​		当java线程的Thread实例的start()方法被调用后，操作系统中的对应线程并不是进入运行状态，而是就绪状态（注意，java的线程中并没有这个状态），操作系统中线程的就绪状态是什么状态呢？
>
>    ​		操作系统中线程处于就绪状态，表示该线程已经满足执行条件，但还不能执行，处于就绪状态的线程需要等待系统的调度，一旦该线程被选中，获得cpu时间片，线程就开始占用cpu(执行该线程的代码)，这时该线程进入运行状态。
>
>    ​		操作系统中处于运行状态的线程在cpu时间片用完之后，会又回到就绪状态，等待cpu的下一次调度，这样操作系统线程就会在就绪状态与运行状态间反复循环，直到线程的代码逻辑执行结束或者发生异常终止，这时线程的状态变为最后一个状态--TERMINATED状态。 
>
>    ​		就绪状态与运行状态都是操作系统中的线程状态，在java语言中，并没有细分这两种状态，而是将两者合并为一个状态--RUNNABLE状态，因此，在Thread.State枚举类中并没有定义线程的就绪与运行状态，这就是java线程状态与操作系统中线程状态的不同之处。
>
>    总结：NEW状态的线程，被调用了start()方法之后，线程就会进入RUNNABLE状态，而其run()方法并不会马上执行，需要在线程获取到cpu时间片之后才真正启动并发执行。
>
> 3. TERMINATED状态：处于RUNNABLE状态的线程在run()方法执行完成后，就变为终止状态TERMINATED,当然，在run()方法执行过程中，如果发生了异常而且没有被捕获，run()方法将被异常终止，此时线程也进入终止状态。
> 4. TIMED_WAITING状态：线程处于一种特殊的状态，即限时等待状态。
> 5. BLOCKED状态：处于BLOCKED(阻塞)状态的线程，并不会占用cpu资源，以下两种情况会让线程进入阻塞转态：
>    * 线程等待获取锁：线程等待获取一个锁，而该锁被其他线程持有，则该线程进入阻塞状态，当其他线程释放了锁，该线程获取到锁时，该线程退出阻塞状态。
>    * IO阻塞(暂时不用看)
>
> 6. WAITING状态：处于WAITING(无限等待)状态的线程。不会被分配给cpu时间片，需要被其他线程显示的唤醒，才会进入就绪状态。以下方法会让线程进入无限等待中：
>    * Object.wait()方法，唤醒方式为Object.notify()/Object.notifyAll();
>    * Thread.join()方法，对应的唤醒方式为：被合入的线程执行结束。
>    * LockSupport.park()方法，唤醒方式为LockSupport.unpark(Thread).

阻塞状态与等待状态的区别是：



线程的基本操作

>1.线程的sleep操作：
>
>​		sleep的作用是让目前执行的线程休眠，让cpu去执行其他任务，从线程状态的角度上讲，线程从运行状态变为阻塞状态。当线程的睡眠时间到后，线程不一定立即得到执行，因为此时cpu可能在执行其他的任务，所以，线程会首先进入就绪状态，等待cpu时间片以便执行。
>
>2.线程的interrupt操作：
>
>​		java语言提供了stop()方法终止正在执行的线程，但同时将Thread的stop()方法设为过时，不建议使用，为什么？在程序中，不能随便终止一个线程的运行，因为我们无法知道线程正运行在什么状态，它可能持有某把锁，强行中断线程可能会导致锁不能释放；或者线程正在操作数据库，强行中断可能会导致数据不一致性问题，因此不推荐使用stop()方法。
>
>​		一个线程什么时候可以退出，只有线程自己知道，Thread的interrupt()方法本质上来说不是中断一个线程的，而是将线程设为中断状态。当调用interrupt()方法时，他有两个作用：
>
>​		（1）如果此线程处于阻塞状态（如调用了Object.wait()、Thread.join()、Thread.sleep()三者之一），就会立即退出阻塞，并抛出InterruptException异常，线程可以通过捕获该异常来做一些处理，然后让线程退出。
>
>​		（2）如果线程处于运行状态，线程就不会受到影响，继续运行，仅仅是线程的中断标记被设置为true.所以程序可以在适当的位置调用isInterrupt()方法来检查自己是否被中断，并退出执行（手动写代码处理）。
>
>3.线程的join操作：
>
>​		假设有两个线程A、B，线程A在执行过程中对线程B有依赖，具体依赖为：线程A需要将线程B的执行流程合并到自己的执行流程中，这就是线程合并，被动方线程B可以叫做被合并线程。调用join()方法的语句可以理解为合并点，合并的本质是：线程A需要在合并点等待，一直到线程B执行完或者等待超时。如果B线程无限时间执行，A线程可以进行限时等待，若B线程在等待时间结束后，仍未完成，则A线程继续执行。
>
>​		调用join()方法的优势是比较简单，当然劣势也很明显--join()方法无法获取B线程的执行结果。
>
>4.线程的yield操作：
>
>​		线程的yield(让步)操作的作用是让目前正在运行的的线程放弃执行，让出cpu的执行权，使cpu去执行其他线程，处于让步状态的jvm层面的线程任然是runnable状态，但是该线程对应的操作系统层面的线程状态会从执行状态变为就绪状态，注意：
>
>（1）.线程放弃执行和重新占有cpu的时间是不确定的，可能刚刚放弃cpu,马上又重新获取了cpu执行权。
>
>（2）.yield不能保证使得当前正在运行的线程迅速转换到就绪状态（切换的时间点由cpu决定？安全点？）。  
>
>总结：yield()方法只是让当前运行的线程暂停了一下，但他不会阻塞该线程，而是让线程由运行状态转入就绪状态，重新争夺cpu的使用权。

线程池原理

java中，线程的创建非常昂贵，需要JVM与OS配合完成大量的工作：
(1):必须为线程堆栈分配和初始化大量内存块，其中至少包括1MB的栈内存。
(2):需要进行系统调用，以便在OS中创建和注册本地线程。
java高并发应用频繁的创建和销毁线程非常低效，而且是不被编程规范所允许的。如何降低java创建线程的成本？必须要使用线程池，使用线程池可以解决两个问题：
(1) 提升性能：线程池能独立负责线程的创建、维护和分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能使用空闲的线程去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。  
(2)线程管理：每个Java线程池会保持一些基本的线程统计信息，例如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到的异步任务进行高效调度。  

java内置锁的核心原理

>​		java内置锁是一种互斥锁，这就意味着，最多只有一个线程能够获取到该锁，当线程B尝试获取线程A持有的锁时，线程B必须等待或者阻塞，直到线程A释放这个锁，如果线程A不释放，则线程B则永远等待下去。
>
>​		java中每个对象都可以用作锁，这些锁成为内置锁。线程进入同步代码块或者同步方法时，会自动获得该锁，在退出时，则会自动释放该锁。获得内置锁的唯一途径就是进入这个锁保护的同步代码块或者同步方法中。
>
>临界区资源与临界区代码片段：
>
>​		临界区资源表示一种可以被多个线程使用的公共资源或者共享数据，但是每次只能有一个线程使用它，一旦临界区资源被占用，想使用该资源的其他线程必须等待。
>
>​		临界区代码段是每个线程中访问临界区资源的那段代码，多个线程必须互斥的对临界区资源进行访问，线程进入临界区代码段之前，必须在进入区申请资源，申请成功后，执行临界区代码片段，执行完成后释放资源。在高并发情况下，可能由于在访问临界区代码片段时，没有进行互斥的访问而导致产生异常结果，这就是在临界区出现了竞态条件问题。
>
>在java中，我们使用synchronized关键字对临界区代码片段进行排他性保护。
>
>```java
>synchronized(syncObject) {
>//critical section
>}
>```
>
>在java中，也可以使用Lock显式锁、原子变量对临界区代码片段进行排他性保护。

synchronized关键字

>​		java中，线程同步使用最多的方法就是使用synchronized关键字，每个java对象中都有一把隐含的锁，使用synchronized(obj)调用相当于获取了obj的内置锁，所以可以使用内置锁对临界区代码片段进行排他性保护。
>
>​		对于小的临界区，我们直接在方法的声明中设置synchronized同步关键字，可以避免竞态条件问题，对于大的临界区代码片段，为了执行效率，最好是将同步方法分为小的临界区代码片段进行排他性保护，如下所示：
>
>```java
>// 未优化
>public class TwoPlus {
>private int sum1 = 0;
>private int sum2 = 0;
>//同步方法
>public synchronized void plus(int val1, int val2){
>   //临界区代码段
>   this.sum1 += val1;
>   this.sum2 += val2;
>}
>// 优化
>public class TwoPlus{
>private int sum1 = 0;
>private int sum2 = 0;
>private Integer sum1Lock = new Integer(1); // 同步锁一
>private Integer sum2Lock = new Integer(2); // 同步锁二
>public void plus(int val1, int val2){
>   //同步块1
>   synchronized(this.sum1Lock){
>   	this.sum1 += val1;
>   }
>   //同步块2
>   synchronized(this.sum2Lock){
>   	this.sum2 += val2;
>   }
>}
>}
>```
>
>

































































































































CAS原理与JUC原子类

​		由于JVM的Synchronized是重量级锁，涉及到操作系统的内核态下互斥锁的使用，因此线程的阻塞与唤醒都会涉及到进程在用户态到内核态的频繁切换，导致重量级锁的开销大、性能低。而Synchronized的轻量级锁使用的是CAS(Compare And Swap,比较并交换)进行自旋抢锁，CAS是cpu指令级别的原子操作，并处于用户态下，所以轻量级锁的开销较小。

​		首先介绍CAS的原理及弊端，然后介绍基于CAS实现的JUC的原子类。

​		什么是CAS?

​		jdk5 所增加的JUC并发包对操作系统的底层CAS原子操作进行了封装，为上层java程序提供了CAS操作的API.

1.Unsafe类中的CAS方法

​		Unsafe类是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全的底层操作，如直接访问系统内存资源、自主管理内存资源等，Unsafe大量的方法都是native方法，基于C++语言实现，这些方法在提升java运行效率、增强java语言底层资源操作能力方面起到了很大的作用。Unsafe类的全限定名为sun.misc.Unsafe，从名字中就可以看出这个类对于普通程序员来说是“危险”的，一般的应用级开发都不会涉及到此类，java官方也不建议直接在应用程序中使用这些类。

> ​	【说明】	
>
> ​		为什么此类取名Unsafe呢？由于使用Unsafe类可以像C语言一样使用指针操作内存空间，这无疑增加了指针的相关问题、内存泄漏问题出现的概率，会使得程序出错的概率变大，因此对于Unsafe类的使用一定要慎重。

​		操作系统层面的CAS是一条cpu的原子指令，正是由于该指令具备原子性，CAS操作数据时，不会造成数据的不一致性问题，Unsafe提供的CAS方法直接通过native方式(封装C++代码)调用底层的cpu指令。

2.使用CAS进行无锁编程

​		CAS是一种无锁算法，该算法依赖两个关键值--期望值(期望内存地址的值 oldValue)和新值，底层cpu利用原子判断操作内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。其大致步骤如下：

		1. 获得字段的期望值.
		1. 计算出需要替换的新值(newValue).
		1. 通过CAS将新值放到字段的内存地址上，如果CAS失败，就重复1、2步直到成功，这种重复俗称CAS自旋。

使用一个简单的例子说明：

​		假如某个内存地址的值是100，现在有两个线程（A、B）使用CAS无锁编程对该内存地址进行更新，线程A欲将其更新为200，线程B欲将其更新为300，两个线程并发执行，谁都可能先执行，但是CAS是原子性操作，对同一个内存地址上的CAS操作同一时刻只能执行一个，假设A的CAS(100,200)先执行，由于内存地址的旧值与CAS的期望值都是100，线程A会执行成功，内存地址的值被改为200.

​		接下来，执行B线程的CAS(100,300)操作，此时内存地址的值为200，不等于CAS的期望值100，线程B操作失败，线程B只能自旋，开启新的循环，这一轮循环中，先获取内存地址的值200，然后在进行CAS(200,300)操作，这次内存地址的值与CAS的预期值(oldValue)相等，线程B操作成功。

​		当CAS将内存地址的值与预期值进行比较时，如果相等，就证明内存地址的值没有被修改过，可以替换成新值，然后继续往下运行，如果不相等，则说明内存地址的值被修改过，放弃操作，重新自旋。当并发修改的线程少，冲突的机会就会少，自旋的次数也会少很多，CAS的性能就会很高；当并发修改的线程多，冲突的机会也会很高，自旋的次数就会很多，此时CAS的性能就会大大下降，所以，提升CAS无锁编程的效率关键在于减少冲突的机会。



























