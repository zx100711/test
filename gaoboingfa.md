# 高并发

说明：引用内容均为《JAVA高并发核心编程 卷2》内容

线程的调度与时间片

>cpu的计算频率非常高，每秒计算数十亿次，因此可以将cpu的计算时间由毫秒的级别进行分段，每个小段叫做一个cpu时间片。
>
>目前操作系统的主流的调度方式是：基于cpu时间片的方式进行线程调度，线程只有得到cpu时间片才可以执行指令，此时处于执行状态，没有得到时间片的线程处于就绪状态，等待系统分配下一个时间片。由于时间片非常短，在各个线程之间快速切换，因此表现出来的特征就是多个线程在“同时执行”或“并发执行”。
>
>线程的调度模型：目前主要分为两种，分时调度模型和抢占式调度模型
>
>* 分时调度模型：系统为每个线程平均分配cpu的时间片，所有线程轮流占用cpu,即在时间片的调度上人人平等。
>* 抢占式调度模型：系统按照线程优先级分配时间片，优先级高的线程优先分配时间片，如果所有就绪的线程优先级相同，则随机选择一个，总体而言，优先级高的线程获得的时间片的相对多一些。
>
>目前大多数的操作系统采用的是抢占式调度模型，Java的线程管理是委托给操作系统完成的，由此可知，Java的线程调度采用的是抢占式模型，由此可知，Java的线程都有优先级。

线程的生命周期

> ​		Java中线程的生命周期分范围6种状态，NEW(新建),RUNNABLE(可执行，包括就绪、运行两种状态)、BLOCKED(阻塞)、WAITING(等待)、TIMED_WAITING(限时等待)、TERMINATED(终止)。
>
> 1. NEW状态：线程创建成功但并没有调用start()方法启动的线程实例属于NEW状态。这里需要说明的是，并不是线程的start()方法一经调用，其状态就由NEW状态转为RUNNABLE状态，因为此时并不意味着线程可以立即获得cpu的时间片并执行，中间还有一系列的内部操作。
>
> 2. RUNNABLE状态：当调用Thread实例的start()方法后，下一步如果线程获取到cpu的时间片开始执行，jvm将异步调用线程的run()方法执行其业务代码，那么在run()方法被异步调用前，jvm做了哪些事情呢？
>
>    ​		当java线程的Thread实例的start()方法被调用后，操作系统中的对应线程并不是进入运行状态，而是就绪状态（注意，java的线程中并没有这个状态），操作系统中线程的就绪状态是什么状态呢？
>
>    ​		操作系统中线程处于就绪状态，表示该线程已经满足执行条件，但还不能执行，处于就绪状态的线程需要等待系统的调度，一旦该线程被选中，获得cpu时间片，线程就开始占用cpu(执行该线程的代码)，这时该线程进入运行状态。
>
>    ​		操作系统中处于运行状态的线程在cpu时间片用完之后，会又回到就绪状态，等待cpu的下一次调度，这样操作系统线程就会在就绪状态与运行状态间反复循环，直到线程的代码逻辑执行结束或者发生异常终止，这时线程的状态变为最后一个状态--TERMINATED状态。 
>
>    ​		就绪状态与运行状态都是操作系统中的线程状态，在java语言中，并没有细分这两种状态，而是将两者合并为一个状态--RUNNABLE状态，因此，在Thread.State枚举类中并没有定义线程的就绪与运行状态，这就是java线程状态与操作系统中线程状态的不同之处。
>
>    总结：NEW状态的线程，被调用了start()方法之后，线程就会进入RUNNABLE状态，而其run()方法并不会马上执行，需要在线程获取到cpu时间片之后才真正启动并发执行。
>
> 3. TERMINATED状态：处于RUNNABLE状态的线程在run()方法执行完成后，就变为终止状态TERMINATED,当然，在run()方法执行过程中，如果发生了异常而且没有被捕获，run()方法将被异常终止，此时线程也进入终止状态。
> 4. TIMED_WAITING状态：线程处于一种特殊的状态，即限时等待状态。
> 5. BLOCKED状态：处于BLOCKED(阻塞)状态的线程，并不会占用cpu资源，以下两种情况会让线程进入阻塞转态：
>    * 线程等待获取锁：线程等待获取一个锁，而该锁被其他线程持有，则该线程进入阻塞状态，当其他线程释放了锁，该线程获取到锁时，该线程退出阻塞状态。
>    * IO阻塞(暂时不用看)
>
> 6. WAITING状态：处于WAITING(无限等待)状态的线程。不会被分配给cpu时间片，需要被其他线程显示的唤醒，才会进入就绪状态。以下方法会让线程进入无限等待中：
>    * Object.wait()方法，唤醒方式为Object.notify()/Object.notifyAll();
>    * Thread.join()方法，对应的唤醒方式为：被合入的线程执行结束。
>    * LockSupport.park()方法，唤醒方式为LockSupport.unpark(Thread).

线程的基本操作